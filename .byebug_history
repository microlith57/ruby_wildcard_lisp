continue
a
n
b.inspect
a
continue
b.inspect
continue
executor.act
executor
n
context
n
others
continue
others
n
output
n
executor.act
executor
n
context
n
context
n
@context
n
output
n
@tree.length
n
continue
@tree.to_a.is_a? ::Array
@tree.to_a.is_a? Array
@tree.to_a.is_a?
@tree.to_a
@tree.t_a
@tree
@tree.is_a? Array
n
@tree
continue
executor.act
executor
n
@tree
exit
index
context
n
context
variable
n
@arguments[0]
index
@arguments
continue
args
args[0]
args
@arguments
@arcuments
context = ExecutionContext.new
context
args
exit
continue
text
n
text
n
text
n
text
continue
n
builtins
n
@others
@context
@token
continue
execute_all text
text
continue
tree.to_a.last
tree.to_a
tree
tokens
continue
other.to_sym
@variables
other
continue
other
continue
other
continue
other
continue
n
context
name
n
program
name
continue
tokens
@tree
depth
continue
exit
continue
arg
continue
arg
continue
args
arg
continue
t
continue
other_tokens
continue
other_tokens
continue
other_tokens
continue
n
continue
other_tokens.slice(1..-1)
other_tokens
continue
n
@others
n
continue
other_tokens.slice 1..-1
other_tokens.slice 1...-1
other_tokens.slice 1...-0
other_tokens.slice 1...-1
other_tokens.slice 1...3
other_tokens.slice 2
other_tokens.slice 1
other_tokens.slice 1, 1
other_tokens.slice 1, -1
other_tokens.slice
other_tokens
continue
@others
@context
@token
continue
text
continue
n
tree
token
depth
n
tree
token
depth
n
token
n
tree
n
tree
token
n
tree
token
depth
n
tokens
n
@tokens
n
continue
tree
n
continue
tree.to_a
tree.to_s
tree
n
continue
tree.to_s
tree.to_a
tree
n
@tokens
n
@tokens
continue
@tree
tree
n
tree
continue
n
continue
@tokens
n
input
continue
@tokens
n
@tokens
n
input
n
tokens
n
continue
back
tokens
n
continue
n
continue
tokens
n
input
continue
WildcardLISP::Interpreter.new.interpret('print ("Hello")')
WildcardLISP::Interpreter.new
WildcardLisp::Interpreter.new
pry
n
continue
token
n
token
n
token
n
token
n
continue
token
n
token
n
token
n
token
n
token
n
continue
@tokens
n
continue
